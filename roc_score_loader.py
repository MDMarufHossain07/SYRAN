# -*- coding: utf-8 -*-
"""roc_score_loader

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hUidl8hWqyLKMLQpYfr2NpPbqJZ5yrau
"""

import numpy as np
import os

from sklearn.metrics import roc_auc_score

ds=[
  "APima",
  "Abreastw",
  "Acardio",
  "AStamps",
  "ACardiotocography",
  "ALymphography",
  "APageBlocks",
  "Aglass",
  "AWaveform",
  "Aannthyroid",
  "Ayeast",
  "Apendigits",
  "AWilt",
  "AHepatitis",
  "Awine",
  "Athyroid",
  "AWBC",
  "Avowels",
  "Avertebral"
]

complexity_weights=[0.001,0.003,0.01,0.03,0.1,0.2,0.3,0.4,0.5,1.0]
chunk_sizes=[2,3,4,5,6,7,8,9,10]
loss_bounds=[0.1,0.2,0.5,1.0,2.0,5.0,10.0]


def get_fn(chunksize, complexity,loss_bound, ds):
    loss_bound=float(loss_bound)
    chunksize=int(chunksize)
    complexity=float(complexity)
    return f"/content/combined/combined/{ds}/{chunksize}/{loss_bound}/{complexity}.npz"

def get_right_fn(chunksize, complexity,loss_bound, ds):
    chunksize0=chunksize
    fn=get_fn(chunksize, complexity, loss_bound, ds)
    #for tries in range(100):
    while not os.path.exists(fn) and chunksize>2:
        chunksize-=1
        fn=get_fn(chunksize, complexity,loss_bound, ds)
    return fn


def load_file(chunksize, complexity,loss_bound, ds):
    fn=get_right_fn(chunksize, complexity,loss_bound, ds)
    return np.load(fn)

def load_one_result(chunksize, complexity, chunknumber, loss_bound, ds):
    f=load_file(chunksize, complexity, loss_bound, ds)
    test_scores, test_labels=f["test_scores"], f["test_labels"]
    if chunknumber!="max":
        test_scores=test_scores[:chunknumber]
        #commented out for now
        assert len(test_scores)==chunknumber, f"Expected {chunknumber} but got {len(test_scores)} ({ds}, {chunksize}, {complexity})"
        #end commented out for now
    scores=np.mean(test_scores, axis=0)
    auc=roc_auc_score(test_labels, scores)
    return auc


def load_one_max(chunksize, complexity, chunknumber, loss_bound, ds):
    f=load_file(chunksize, complexity, loss_bound, ds)
    test_scores, test_labels=f["test_scores"], f["test_labels"]
    individuals=f["individuals"]
    if chunknumber!="max":
        test_scores=test_scores[:chunknumber]
        individuals=individuals[:chunknumber]
        #commented out for now
        assert len(test_scores)==chunknumber, f"Expected {chunknumber} but got {len(test_scores)} ({ds}, {chunksize}, {complexity})"
        #end commented out for now
    return np.max(individuals)
    scores=test_scores[np.argmax(individuals)]
    #scores=np.mean(test_scores, axis=0)
    auc=roc_auc_score(test_labels, scores)
    return auc

## for equation and roc score

def load_one_best(chunksize, complexity, chunknumber, loss_bound, ds):
    f = load_file(chunksize, complexity, loss_bound, ds)

    test_scores = f["test_scores"]
    test_labels = f["test_labels"]
    individuals = f["individuals"]
    equations = f["equations"]

    if chunknumber != "max":
        test_scores = test_scores[:chunknumber]
        individuals = individuals[:chunknumber]
        equations = equations[:chunknumber]

    best_index = np.argmax(individuals)
    best_equation = equations[best_index]

    # Compute ROC based on the same best chunk
    scores = test_scores[best_index]
    auc = roc_auc_score(test_labels, scores)

    return auc, best_equation



def load_result(chunksize, complexity, chunknumber, loss_bound=1):
    #loss_bound is unused for now, just a placeholder for the next set of results
    return {d: load_one_result(chunksize, complexity, chunknumber, loss_bound, d) for d in ds}

def load_max_results(chunksize, complexity, chunknumber, loss_bound=1):
    #loss_bound is unused for now, just a placeholder for the next set of results
    return {d: load_one_max(chunksize, complexity, chunknumber, loss_bound, d) for d in ds}


if __name__=="__main__":
    chunksize=2
    complexity=0.1
    chunknumber=50
    loss_bound=1
    results=load_result(chunksize, complexity, chunknumber, loss_bound)
    max_results=load_max_results(chunksize, complexity, chunknumber, loss_bound)
    for d in ds:
        print(f"{d}: {results[d]:.4f}, {max_results[d]:.4f}")
    print(np.mean(list(results.values())))
    print(np.mean(list(max_results.values())))